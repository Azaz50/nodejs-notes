ExpressJS : Implement Form Validation
----------------------------------------------------------
npm install express-validator
----------------------------------------------------------
Implement form validation using express-validator
----------------------------------------------------------

const { body, validationResult } = require('express-validator');

var validationRegistration = [
    body('username').notEmpty().withMessage('Username is required'),
    body('password').notEmpty().withMessage('Password is required').isLength({ min: 6 }).withMessage('Password must be at least 6 characters long'),
    body('email').notEmpty().withMessage('Email is required').isEmail().withMessage('Invalid email format'),
]
app.post('/saveform', validationRegistration, (req, res) => {
    const errors = validationResult(req);
    const result = validationResult(req);
    res.send(result);
})
----------------------------------------------------------
================ Form Validation =======================
----------------------------------------------------------

Validation Methods
• notEmpty()
• isEmail()
• isLength()
• isNumeric()
• isAlpha()
• isAlphanumeric()
• isURL()
• isDate()
• isStrongPassword()
• isUpperCase()
• isLowerCase()
• matches(pattern)

Sanitization Methods
. trim()
• Itrim()
• rtrim()
• escape()
• unescape()
• normalizeEmail()
• tolnt()
• toFloat()
• toBoolean()

Custom Validation
• custom(validator)
• customSanitizer(sanitizer)

=========================================================================================
### Understanding Form Validation in Express.js

Form validation is a critical part of any web application that accepts user input. It ensures that the data submitted through forms is in the correct format, meets specific criteria, and is safe to process and store. In Express.js, while you can manually write validation logic, using a dedicated library like `express-validator` simplifies the process, making it more robust and easier to maintain.

#### Why is Form Validation Important?

1.  **Data Integrity:** Ensures that the data stored in your database is clean, correct, and useful. For example, validating that an email field contains a properly formatted email address.
2.  **Security:** Protects your application from malicious data. Improper validation can lead to security vulnerabilities like SQL Injection, Cross-Site Scripting (XSS), and other attacks. Sanitizing input is a key part of this.
3.  **User Experience:** Provides clear and immediate feedback to users, helping them correct mistakes without having to resubmit the entire form.

#### Core Concepts of `express-validator`

`express-validator` is a set of Express middleware that wraps the popular `validator.js` library. It allows you to define validation rules declaratively.

**1. Installation:**
First, you need to add it to your project:
```bash
npm install express-validator
```

**2. Basic Usage:**
You chain validation rules to the `body`, `query`, or `param` functions from `express-validator`.

```javascript
const { body, validationResult } = require('express-validator');

app.post(
    '/user',
    // Validate that the 'username' field is an email.
    body('username').isEmail(),
    // Validate that the 'password' field is at least 5 chars long.
    body('password').isLength({ min: 5 }),
    (req, res) => {
        // `validationResult` finds the validation errors in this request and wraps them in an object with handy functions
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            // If there are errors, respond with a 400 Bad Request status and the errors.
            return res.status(400).json({ errors: errors.array() });
        }

        // If validation passes, you can proceed with your logic.
        // e.g., save the user to the database.
        res.send('User created successfully!');
    }
);
```

#### Key Validation and Sanitization Chains

You can chain multiple validation and sanitization methods together.

**Validation Chain:**
Checks the input against a set of rules.

```javascript
body('email')
  .notEmpty().withMessage('Email is required.')
  .isEmail().withMessage('Must be a valid email address.')
  .normalizeEmail() // Sanitizer
```

**Sanitization Chain:**
Modifies the input data to a standard format.

```javascript
body('comment')
  .trim()    // Remove leading/trailing whitespace
  .escape()  // Convert HTML special characters to prevent XSS
```

#### Displaying Errors in a View (like EJS)

In a typical Model-View-Controller (MVC) setup, you would render the form again with the errors and the user's submitted data.

**Route:**
```javascript
app.post('/submit-form', [
    body('name').notEmpty().withMessage('Name cannot be empty.'),
    body('email').isEmail().withMessage('Please provide a valid email.')
], (req, res) => {
    const errors = validationResult(req);
    const { name, email } = req.body;

    if (!errors.isEmpty()) {
        // There are errors. Render the form again with sanitized values and error messages.
        res.render('myform', {
            errors: errors.array(),
            data: { name, email } // Send back the sanitized data
        });
    } else {
        // Data is valid. Process it.
        res.send('Form submitted successfully!');
    }
});
```

**EJS View (`myform.ejs`):**
```html
<% if (typeof errors !== 'undefined') { %>
    <ul>
        <% errors.forEach(function(error) { %>
            <li><%= error.msg %></li>
        <% }) %>
    </ul>
<% } %>

<form action="/submit-form" method="POST">
    <input type="text" name="name" value="<%= typeof data !== 'undefined' ? data.name : '' %>">
    <input type="email" name="email" value="<%= typeof data !== 'undefined' ? data.email : '' %>">
    <button type="submit">Submit</button>
</form>
```

This combination of validation rules, error handling, and user feedback provides a complete and secure form handling workflow in an Express.js application.
================================================================================================================================
--------------------------------- Employee Create Form Validation from my GMI project ------------------------------------------
================================================================================================================================
Perfect — I’ll give you a ready-to-use express-validator validation middleware for your createEmployee flow plus integration notes and helper functions so you can validate most of the 48 fields server-side. Main goals covered:

required vs optional fields

type checks (string, number, date, boolean)

enums (allowed values)

format checks (email, phone, IBAN-ish, time)

foreign-key numeric-id → MongoDB ObjectId async checks (Nation, Company, Department, Designation, EmpStatus)

sanitized output using matchedData

clear error response (HTTP 422)

You can drop this into your project and wire it to your route before createEmployee.

1) Install (if not already)
npm install express-validator

2) validators/employeeValidator.js

Create a new file and paste this (adjust Model imports & enum values to your actual values):

// validators/employeeValidator.js
const { body } = require('express-validator');
const Nation = require('../models/Nation');
const Company = require('../models/Company');
const Department = require('../models/Department');
const Designation = require('../models/Designation');
const EmpStatus = require('../models/EmpStatus');

// helper: check numeric id exists in referenced model
const checkLookup = (Model, lookupField, friendlyName) => {
  return body().custom(async (value, { req }) => {
    const val = req.body[lookupField];
    if (val === undefined || val === null || val === '') return true; // optional here — make required by adding notEmpty on field
    // if it is already an ObjectId-like string you may skip numeric lookup
    if (/^[0-9a-fA-F]{24}$/.test(String(val))) return true;
    const numericId = parseInt(val, 10);
    if (isNaN(numericId)) throw new Error(`${friendlyName} must be a numeric id or ObjectId`);
    const doc = await Model.findOne({ [lookupField]: numericId });
    if (!doc) throw new Error(`${friendlyName} not found for id ${numericId}`);
    // ok
    return true;
  });
};

const employeeValidation = [
  // 1) emp_id -> generated server side; should not be provided by client. If client sends, ignore or ensure numeric:
  body('emp_id').optional().isInt().withMessage('emp_id must be integer'),

  // 2) emp_name - required
  body('emp_name').trim().notEmpty().withMessage('Employee name is required')
    .isLength({ min: 2, max: 200 }).withMessage('emp_name length must be 2-200 chars'),

  // 3) emp_user_nm - will be generated but validate optional client input
  body('emp_user_nm').optional().isString().isLength({ min: 3 }).withMessage('emp_user_nm invalid'),

  // 4) emp_password - server generates; if client sends for update validate:
  body('emp_password').optional().isLength({ min: 6 }).withMessage('Password too short'),

  // 5) emp_email
  body('emp_email').optional({ checkFalsy: true }).isEmail().withMessage('Invalid email').normalizeEmail(),

  // 6) emp_visa_typ - optional enum
  body('emp_visa_typ').optional({ checkFalsy: true }).isIn(['visit','work','residency','other']).withMessage('Invalid visa type'),

  // 7) emp_fname
  body('emp_fname').optional({ checkFalsy: true }).isLength({ min: 2 }).withMessage('First name too short'),

  // 8) emp_dob - date
  body('emp_dob').optional({ checkFalsy: true }).isISO8601().toDate().withMessage('Invalid date of birth (use YYYY-MM-DD)'),

  // 9) emp_mdl_inc_no - optional string/number
  body('emp_mdl_inc_no').optional({ checkFalsy: true }).isString(),

  // 10) emp_visa_exp_dt - date
  body('emp_visa_exp_dt').optional({ checkFalsy: true }).isISO8601().toDate().withMessage('Invalid visa expiry date'),

  // 11) emp_ph - phone number
  body('emp_ph').optional({ checkFalsy: true }).isMobilePhone('any').withMessage('Invalid phone number'),

  // 12) emp_gender - enum
  body('emp_gender').optional({ checkFalsy: true }).isIn(['Male','Female','Other']).withMessage('Invalid gender'),

  // 13) emp_mdl_inc_expy - date
  body('emp_mdl_inc_expy').optional({ checkFalsy: true }).isISO8601().toDate(),

  // 14) emp_nation_id -> foreign key numeric check (Nation table)
  body('emp_nation_id').optional({ checkFalsy: true })
    .custom(async (val) => {
      if (!val) return true;
      if (/^[0-9a-fA-F]{24}$/.test(String(val))) return true;
      const numericId = parseInt(val, 10);
      if (isNaN(numericId)) throw new Error('emp_nation_id must be numeric id or ObjectId');
      const doc = await Nation.findOne({ nation_id: numericId });
      if (!doc) throw new Error(`Nationality not found for id ${numericId}`);
      return true;
    }),

  // 15) emp_pspt_no
  body('emp_pspt_no').optional({ checkFalsy: true }).isString(),

  // 16) emp_pspt_exp_dt - date
  body('emp_pspt_exp_dt').optional({ checkFalsy: true }).isISO8601().toDate(),

  // 17) emp_iqama_no
  body('emp_iqama_no').optional({ checkFalsy: true }).isString(),

  // 18) emp_iqama_exp_dt - date
  body('emp_iqama_exp_dt').optional({ checkFalsy: true }).isISO8601().toDate(),

  // 19) emp_marital_status (note: fixed field name without space)
  body('emp_marital_status').optional({ checkFalsy: true }).isIn(['single','married','divorced','widowed']).withMessage('Invalid marital status'),

  // 20) emp_emgcy_cnt_name
  body('emp_emgcy_cnt_name').optional({ checkFalsy: true }).isLength({ min: 2 }),

  // 21) emp_emgcy_cnt_no
  body('emp_emgcy_cnt_no').optional({ checkFalsy: true }).isMobilePhone('any').withMessage('Invalid emergency contact number'),

  // 22) emp_cmp_id -> Company lookup
  body('emp_cmp_id').optional({ checkFalsy: true })
    .custom(async (val) => {
      if (!val) return true;
      if (/^[0-9a-fA-F]{24}$/.test(String(val))) return true;
      const num = parseInt(val, 10);
      if (isNaN(num)) throw new Error('emp_cmp_id must be numeric id or ObjectId');
      const doc = await Company.findOne({ cmp_id: num });
      if (!doc) throw new Error(`Company not found for id ${num}`);
      return true;
    }),

  // 23) emp_job_title
  body('emp_job_title').optional({ checkFalsy: true }).isString(),

  // 24) emp_dept_id
  body('emp_dept_id').optional({ checkFalsy: true })
    .custom(async (val) => {
      if (!val) return true;
      if (/^[0-9a-fA-F]{24}$/.test(String(val))) return true;
      const num = parseInt(val, 10);
      if (isNaN(num)) throw new Error('emp_dept_id must be numeric id or ObjectId');
      const doc = await Department.findOne({ dept_id: num });
      if (!doc) throw new Error(`Department not found for id ${num}`);
      return true;
    }),

  // 25) emp_desg_id
  body('emp_desg_id').optional({ checkFalsy: true })
    .custom(async (val) => {
      if (!val) return true;
      if (/^[0-9a-fA-F]{24}$/.test(String(val))) return true;
      const num = parseInt(val, 10);
      if (isNaN(num)) throw new Error('emp_desg_id must be numeric id or ObjectId');
      const doc = await Designation.findOne({ desg_id: num });
      if (!doc) throw new Error(`Designation not found for id ${num}`);
      return true;
    }),

  // 26) emp_manager_nm
  body('emp_manager_nm').optional({ checkFalsy: true }).isString(),

  // 27) emp_salary_payment_typ (monthly / quarterly / yearly)
  body('emp_salary_payment_typ').optional({ checkFalsy: true }).isIn(['monthly','quarterly','yearly']).withMessage('Invalid salary payment type'),

  // 28) emp_bs_salary - numeric
  body('emp_bs_salary').optional({ checkFalsy: true }).isFloat({ min: 0 }).withMessage('Invalid base salary'),

  // 29) emp_wk_permit_no
  body('emp_wk_permit_no').optional({ checkFalsy: true }).isString(),

  // 30) emp_wk_permit_expy - date
  body('emp_wk_permit_expy').optional({ checkFalsy: true }).isISO8601().toDate(),

  // 31) emp_type (permanent / contract / temporary / provision)
  body('emp_type').optional({ checkFalsy: true }).isIn(['permanent','contract','temporary','provision']).withMessage('Invalid employee type'),

  // 32) emp_allowances - numeric (total allowances)
  body('emp_allowances').optional({ checkFalsy: true }).isFloat({ min: 0 }),

  // 33) emp_wk_location
  body('emp_wk_location').optional({ checkFalsy: true }).isString(),

  // 34) emp_status_id -> EmpStatus lookup
  body('emp_status_id').optional({ checkFalsy: true })
    .custom(async (val) => {
      if (!val) return true;
      if (/^[0-9a-fA-F]{24}$/.test(String(val))) return true;
      const num = parseInt(val, 10);
      if (isNaN(num)) throw new Error('emp_status_id must be numeric id or ObjectId');
      const doc = await EmpStatus.findOne({ emp_status_id: num });
      if (!doc) throw new Error(`Employment status not found for id ${num}`);
      return true;
    }),

  // 35) emp_joining_dt - date
  body('emp_joining_dt').optional({ checkFalsy: true }).isISO8601().toDate(),

  // 36) emp_exit_dt - date (should be after joining if present)
  body('emp_exit_dt').optional({ checkFalsy: true })
    .isISO8601().toDate()
    .custom((exitDt, { req }) => {
      if (!exitDt) return true;
      const joining = req.body.emp_joining_dt ? new Date(req.body.emp_joining_dt) : null;
      if (joining && new Date(exitDt) < new Date(joining)) {
        throw new Error('emp_exit_dt must be after emp_joining_dt');
      }
      return true;
    }),

  // 37) emp_duty_type (office time / part time)
  body('emp_duty_type').optional({ checkFalsy: true }).isIn(['office time','part time']).withMessage('Invalid duty type'),

  // 38) emp_joining_tm (HH:MM)
  body('emp_joining_tm').optional({ checkFalsy: true })
    .matches(/^([01]\d|2[0-3]):([0-5]\d)$/).withMessage('Invalid joining time (HH:MM)'),

  // 39) emp_exit_tm (HH:MM)
  body('emp_exit_tm').optional({ checkFalsy: true })
    .matches(/^([01]\d|2[0-3]):([0-5]\d)$/).withMessage('Invalid exit time (HH:MM)'),

  // 40) emp_distance_meter - number
  body('emp_distance_meter').optional({ checkFalsy: true }).isFloat({ min: 0 }),

  // 41) emp_bank_nm
  body('emp_bank_nm').optional({ checkFalsy: true }).isString(),

  // 42) emp_acc_no - alpha num
  body('emp_acc_no').optional({ checkFalsy: true }).isAlphanumeric().withMessage('Invalid account number'),

  // 43) emp_iban_no - basic IBAN-ish validation (not full IBAN validation)
  body('emp_iban_no').optional({ checkFalsy: true }).matches(/^[A-Z0-9]{15,34}$/i).withMessage('Invalid IBAN format'),

  // 44) emp_bk_type (bank / agent bank / exchange)
  body('emp_bk_type').optional({ checkFalsy: true }).isIn(['bank','agent bank','exchange']),

  // 45) emp_bk_branch
  body('emp_bk_branch').optional({ checkFalsy: true }).isString(),

  // 46) emp_photo - allow url or base64 or file upload name
  body('emp_photo').optional({ checkFalsy: true }).isString().withMessage('emp_photo must be a string (url/base64/filename)'),

  // 47) emp_add - address
  body('emp_add').optional({ checkFalsy: true }).isLength({ min: 2 }),

  // 48) emp_ph_div_lock (0 or 1)
  body('emp_ph_div_lock').optional().isIn([0,1,'0','1']).withMessage('emp_ph_div_lock must be 0 or 1'),
];

module.exports = employeeValidation;


Note: I made many fields optional({ checkFalsy: true }) because real employee forms often submit partial data. If you want a field to be mandatory, replace .optional(...) with .notEmpty().withMessage('... is required').

3) Use in route
// routes/employee.js
const express = require('express');
const router = express.Router();
const employeeValidation = require('../validators/employeeValidator');
const { createEmployee } = require('../controllers/employeeController');

router.post('/create', employeeValidation, createEmployee);

module.exports = router;

4) Controller changes — use validationResult & matchedData

Modify createEmployee to reject invalid requests and use sanitized data:

const { validationResult, matchedData } = require('express-validator');

exports.createEmployee = async (req, res) => {
  try {
    // 1) validation
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(422).json({ errors: errors.array() });
    }

    // 2) get only validated/sanitized fields
    const body = matchedData(req, { locations: ['body'] });

    // 3) convert numeric foreign keys -> ObjectIds (optional helper)
    await convertNumericLookupsToObjectIds(body);

    // ... existing logic (generate emp_id, hash password etc) using 'body' instead of req.body

  } catch (error) {
    // existing error handling
  }
};

5) Helper: convert numeric lookups → ObjectId

You already do this in your function — extract to helper so validator + controller remain clear.

const isObjectId = id => /^[0-9a-fA-F]{24}$/.test(String(id));

async function convertNumericLookupsToObjectIds(body) {
  const lookups = [
    { model: Nation, key: 'emp_nation_id', lookupField: 'nation_id' },
    { model: Company, key: 'emp_cmp_id', lookupField: 'cmp_id' },
    { model: Department, key: 'emp_dept_id', lookupField: 'dept_id' },
    { model: Designation, key: 'emp_desg_id', lookupField: 'desg_id' },
    { model: EmpStatus, key: 'emp_status_id', lookupField: 'emp_status_id' }
  ];

  for (const lookup of lookups) {
    const id = body[lookup.key];
    if (!id) continue;
    if (!isObjectId(id)) {
      const numericId = parseInt(id, 10);
      if (isNaN(numericId)) {
        throw new Error(`Invalid ID format for ${lookup.key}: '${id}'`);
      }
      const doc = await lookup.model.findOne({ [lookup.lookupField]: numericId });
      if (!doc) throw new Error(`${lookup.key} not found for id ${numericId}`);
      body[lookup.key] = doc._id; // replace with ObjectId
    }
  }
}

6) Tips & best practices

Server-side first: Always validate server-side even if you have client-side validation.

Use matchedData to avoid trusting extra/malicious fields.

Keep validators modular (one file per resource).

If fields are required for specific employee types, use conditional validators:

body('emp_iqama_no').if(body('emp_nation_id').equals('someCountryId')).notEmpty()


Return consistent errors: { errors: [ { param, msg } ] } makes frontend mapping easier.

Test validation with tools like Postman or automated tests using supertest.

For IBAN/account validation, third-party libs exist if you need exact checks.

Dates/timezones: .toDate() produces JS Date in server timezone — be explicit if you need UTC.

7) Quick example: error response handling in client

Your frontend already shows error box; map errors.array() to field-level messages.
====================================================================== End ==================================================================

